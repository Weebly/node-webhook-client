.chapter(data-title='Weebly Node.js Webhook Client Tutorial')
  .step(data-title='Welcome!', data-file='tutorial/config.json')
    h2 Welcome!

    p The tutorial's navigation controls are located above this text. Use <i class="fa fa-fw fa-play"></i> to move to the next step of the tutorial. Use <i class="fa fa-fw fa-play fa-rotate-180"></i> to move to the previous step of the tutorial (if there is one). Use <i class="fa fa-fw fa-list"></i> to see an overview of all the steps in the tutorial.

    h3 What You Will Learn

    p How [Weebly Node.js Webhook Client](https://github.com/Weebly/node-webhook-client) works (code review)
    
    .chapter(data-title='Live Code Setup')
      .step(data-title='Prerequisites', data-file='tutorial/prerequisites.txt')
        :markdown
          ## What You Need

          1. [Weebly Retail Account](https://www.weebly.com/)
          2. [Weebly Developer Account](https://dev.weebly.com/pf_apps_devAccount.html)
          3. [Weebly Developer Admin Portal](https://www.weebly.com/developer-admin)
          4. [Weebly App](https://dev.weebly.com/pf_apps_register.html)
          5. [Weebly Node.js Webhook Client](https://github.com/Weebly/node-webhook-client) cloned locally
          6. [Git](https://git-scm.com/downloads) installed on your local workstation
          7. Your favorite code editor
          8. Browser (Google Chrome is recommended)

      .step(data-title='Register Your App', data-file='tutorial/prerequisites.txt', data-highlight='1-7')
        :markdown
          ## Define Your Weebly App to Obtain API Keys

          Login to the [Weebly Developer Admin Portal](https://www.weebly.com/developer-admin) and then [Register a New App](https://dev.weebly.com/pf_apps_register.html) you will use for this tutorial.

          App names must be unique across all apps in the Weebly Platform.

          > Replace the template string {{PREFIX}}  below with your personal prefix, I recommend using the first character of your first name and the first three characters of your last name.
          > Example: If your name is James Gunn, you would name the directory `jgun-event-consumer`.

          1. App Name: `{{PREFIX}}-evt-sub` (short for webhook subscriber)
          2. Category: `Services`

      .step(data-title='App Setup', data-file='README.md')
        :markdown
          ## Usages

          Please choose from one of the [Usages](https://github.com/weebly/node-webhook-client#usage) in the `README.md` file to setup this app for live operation and to see it in action.

          We are going to omit how to setup this app, so we can focus on what the code is actually doing.

    .chapter(data-title='App Server')
      .step(data-title='Express.js', data-file='server.js', data-highlight='16-20')
        :markdown
          ## About the Web Server

          This app uses the [Express.js](https://expressjs.com/) web application framework. Since [Express.js](https://expressjs.com/en/starter/installing.html) is well documented, this tutorial will not go into too many details, but there are some specific pieces of code you should understand.

          Express.js allows developers to [write middleware](https://expressjs.com/en/guide/writing-middleware.html) for their applications to customize how their applications handle requests and responses.

          While it is outside of the scope of this tutorial, it is important to note, there are other types of middlware Express allows you to use:

          * [Application-Level Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.application)
          * [Router-level Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.router)
          * [Error-Handling Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.error-handling)
          * [Built-In Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.built-in)
          * [Third-Party Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.third-party)
          
      .step(data-title='Application Level Middleware', data-file='server.js', data-highlight='22-36)
        :markdown
          ## Application-Level Middleware

          Express.js allows developers to [write middleware](https://expressjs.com/en/guide/writing-middleware.html) for their applications.

          Highlighted is the instantiation of custom [Express.js - Application-Level Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.application) written specifically for the Weebly Node Webhook Client,
          
      .step(data-title='Weebly Middleware', data-file='middleware/weebly.js')
        :markdown
          ## Weebly Middleware

          This piece of custom, application-level middleware exposes your Weebly API Keys for this app to the [request](https://expressjs.com/en/4x/api.html#req) and [response](https://expressjs.com/en/4x/api.html#res) objects in Express.

      .step(data-title='Mounting Middleware', data-file='server.js', data-highlight='38-42)
        :markdown
          ## Mounting Middleware

          Here the code defines specifically which middleware, and the order of execution, each piece of middleware is to operate upon for all HTTP requests received by this app to `/oauth` or `/webhooks`.

          Specifically, you can see that each route has its own middleware chain and they both share the Application-Level, Weebly Middleware, which is executed before the Router-Level Middleware.

          * Requests to `/oauth[...]` will be sent to the Weebly Middleware, and then to the OAuth Routing Middleware
          * Requests to `/webhooks[...]` will be sent to the Weebly Middleware, and then to the Webhook Routing Middleware 

        .chapter(data-title='OAuth - Router Middleware')
          .step(data-title='OAuth - Router Middleware', data-file='app/oauth-router.js')
            :markdown
              ## OAuth Middleware 

              `oauth-router.js` is a piece of custom [Express.js Routing Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.router) that handles all incoming HTTP requests beginning with `/oauth`.

              Please read the [App Authorization and Installation Flow](https://dev.weebly.com/pf_apps_authorize_and_install.html) to understand each phase a Weebly app experiences while being installed...

          .step(data-title='OAuth - Phase One', data-file='app/oauth-router.js', data-highlight='10-15')
            :markdown
              ## Oauth - Phase One

              First, the code will accept HTTP **GET** requests going to `/oauth/phase-one`, and immediately defines the `clientId` and `secretKey` variables which were made available from the Weebly Middleware.

          .step(data-title='Request Invalidation', data-file='app/oauth-router.js', data-highlight='17-32')
            :markdown
              ## Request Validation

              As a developer, you must **KNOW with great confidence** the inbound requests your web applications can trust.

              In this section of code you can see how to invalidate requests to ensure that requests sent to this particular route can be trusted as coming from Weebly. 
              Here, a comparison object is created and converted into a string (verification HMAC) using identical values to the Weebly generated HMAC.
              then you use these two pieces of data to invalidate the HMAC query parameter received in requests to this route, are actually requests you can trust were sent from Weebly servers.

              You can read the details about this [here](https://dev.weebly.com/pf_apps_authorize_and_install.html#decode-and-verify-the-hash), but to provide you the 'gist' of what happens:

              1. A Weebly site administrator (user) clicks the "Add App" button for your app in [Weebly App Center](https://www.weebly.com/app-center)
              2. Weebly presents the 'user' with the list of persmissions (**scopes** defined in your `manifest.json`) that your app is requesting
              3. The 'user' can either authorize (connect) or decline, but assume the 'user' accepts for sake of example
              4. Weebly creates an HMAC-SHA256 encoded hash of the request parameters using your Weebly App **SECRET**, which means **ONLY YOU** should be able to recreate that **EXACT** HMAC string using identical values
              5. If your **generated** HMAC string is IDENTICAL to the HMAC in the request query parameters, you can consider this a "verified request" (trusting that it came from Weebly) and proceed with code execution

          .step(data-title='Request an Authorization Code', data-file='app/oauth-router.js', data-highlight='42-58')
            :markdown
              ## Requesting an Authorization Code

              Since the request is trusted, you first generate the second phase URL, callback parameters, and version (if included in the original request).

              Then your app tells the [Express response object](https://expressjs.com/en/4x/api.html#res) to redirect to the appropriate Weebly URL to obtain an `authorization_code`.

              If the redirect is successfully formed/accepted, Weebly will respond to your redirect by sending a new HTTP request to containing an `authorization_code` correlating to the Weebly User and Site.

          .step(data-title='OAuth - Phase Two', data-file='app/oauth-router.js', data-highlight='61-66')
            :markdown
              ## Oauth - Phase Two

              Here, the code designates it will accept HTTP **GET** requests going to `/oauth/phase-two`, and immediately defines the `clientId` and `secretKey` variables which were made available from the Weebly Middleware.

          .step(data-title='Exchange for `access_token`', data-file='app/oauth-router.js', data-highlight='68-90')
            :markdown
              ## Exchanging Authorization Code for an `access_token`

              > NOTE: It is of **CRITICAL IMPORTANCE** that you take every measure possible to secure and mitigate attacks to obtain your Weebly app API Keys (including your app's `manifest.json` file). If you do not, and attackers gain access, this section of code is at risk, and places at risk your app customer data on Weebly.

              There are a few things happening here to exchange the `authorization_code` for a valid `access_token`:
              
              1. The body is formed for the HTTP POST request which includes: `authorization_code`, `client_id`, `client_secret`
              2. The `redirect_url` parameter is used as the destination for the subsequent code-token exchange request
              3. App initiates POST request to **redirect_url** (Weebly API endpoint `/app-center/oauth/access_token`
              4. An `access_token` will be received upon a successful request, and should be stored securely by your app for future [Weebly API](https://dev.weebly.com/pf_apis_about.html) requests

          .step(data-title='Service Initialization', data-file='app/oauth-router.js', data-highlight='91')
            :markdown
              ## Service Initialization

              Many developers get confused about when their app is actually "installed" and "connected" to a Weebly site.
              
              This blank line of the code represents the **point-in-time** during the [App Authorization and Installation Flow](https://dev.weebly.com/pf_apps_authorize_and_install.html#redirect-back-to-weebly-to-trade-auth-code-for-permanent-token) when your app/service has an opportunity to ensure the most optimal User Experience by performing any:

              * Account/User setup
              * New User Verification(s)
              * Weebly Plan/Feature Checks
              * Security Checks

              These types of service initializations should occur prior to [redirecting to the final destination](https://dev.weebly.com/pf_apps_authorize_and_install.html#redirect-to-final-destination) which we describe in the next step of the tutorial.

          .step(data-title='Connecting Your App', data-file='app/oauth-router.js', data-highlight='92')
            :markdown
              ## Final Redirect - Connecting your App

              To reach this point in the code, your app must have:

              1. Successfully validated an installation request from Weebly to your `manifest.json` *callback_url* property
              2. Redirected back to Weebly with the expected request/payload
              3. Successfully received an `authorization_code` from the **phase-two** portion of the OAuth2 Authorization Flow
              4. Redirected back to Weebly to exchange your `authorization_code` for a valid API `access_token`
              5. Executed any account/user setup and validations internal to your app or service

              This final redirect indicates to Weebly that your app has completed all necessary setup and configuration operations, and the app should be considered "installed" and "connected".

              If your app does not perform this final redirect, your app will be in a **disconnected** state.

        .chapter(data-title='Webhook - Router Middleware')
          .step(data-title='Webhook Router Middleware', data-file='app/webhooks-router.js')
            :markdown
              ## Webhooks Middleware

              `webhooks-router.js` is custom [Express.js Routing Middleware](https://expressjs.com/en/guide/using-middleware.html#middleware.router) handling all incoming HTTP requests beginning with `/webhooks`.

              The URL where events will be sent is defined in `webhooks.callback_url` property of your `manifest.json`.

              Please read the [Receiving Webhooks](https://dev.weebly.com/pf_wh_webhooks.html#receive-webhooks) to understand the data Weebly will POST to your app when events occur to which your app has subscribed.

          .step(data-title='Subscribing to Events', data-file='manifest.json', data-highlight='9-11')
            :markdown
              ## Subscribing to Events

              Weebly apps can [subscribe to events](https://dev.weebly.com/pf_wh_webhooks.html#subscribe-to-webhooks). There are several different types of events available for your app to be notified about when they occur upon a site where your app is installed:

              * [User Events](https://dev.weebly.com/pf_wh_user.html)
              * [Site Events](https://dev.weebly.com/pf_wh_site.html)
              * [Store Events](https://dev.weebly.com/pf_wh_store.html)
              * [Membership Events](https://dev.weebly.com/pf_wh_member.html)
              * [App Events](https://dev.weebly.com/pf_wh_app.html)
              * [Form Events](https://dev.weebly.com/pf_wh_form.html)
              * [Blog Events](https://dev.weebly.com/pf_wh_blog.html)
              * [Dashboard Card Events](https://dev.weebly.com/pf_wh_card.html)

              You define the types of Weebly Events your app will receive in the **webhooks.events** property in your `manifest.json`.

              The default `events` this app subscribes to are: `app.uninstall`, `user.update`, `site.publish`, `site.delete`. These are all crucial events for any Weebly App and are highly recommended for subscription.

          .step(data-title='Receiving Events', data-file='app/webhooks-router.js', data-highlight='9-11')
            :markdown
              ## Subscribing to Events
                The code here indicates this app will only HTTP POST requests sent to:

                `{{YOUR_APP_ROOT_URL}}/webhooks/callback` will be accepted, but you still need to peform request invalidation to be certain Weebly sent the request.

          .step(data-title='Invalidating Webhook Event Requests', data-file='app/webhooks-router.js', data-highlight='12-33')
            :markdown
              ## Invalidating Webhook Event Requests

              To prevent malicious attackers from spoofing or forging requests to your `webhook.callback_url` you need to invalidate the request.

              All Webhook Event POST Request Body will contain:

              * `client_id`: Your app's Client ID from the Weebly Developer Admin Portal
              * `client_version`:  The version of your app which generated the event (helpful in cases of managing multiple versions)
              * `event`: The event name (according to the Weebly Webhook docs)
              * `timestamp`: Unix epoch timestamp when the event occurred according to Weebly servers
              * `data`: Event-specific data, see the respective Webhook Event Type docs
              * `hmac`: `client_id, `client_version`, `event`, `timestamp`, and `data` sent in the request to be used to invalidate incoming event requests

              Similar to verifying the HMAC hash received on app installation, here we prepare a comparison object/string and then re-generate the HMAC to be certain the request was actually created and sent by Weebly.

          .step(data-title='Handling Events', data-file='app/webhooks-router.js', data-highlight='32-42')
            :markdown
              ## Handling Events

              Here, the code is merely logging the event headers and requests to console, but this is an opportunity for your app to become event-driven!

              In production apps, this is the point-in-time to handle events allowing your app to behave proactively, addressing concerns such as:

              * Saving events to persistent storage (logging)
              * Making relevant Weebly API requests based on your app business logic
              * Performing internal data update(s)for the respective customer/site
              * Revoking access/permissions (in cases of `app.uninstall` or `site.delete` events)
              * Alerting/Reporting to customer(s) of related changes within your app/service

          .step(data-title='Webhook Event Responses', data-file='app/webhooks-router.js', data-highlight='44')
            :markdown
              ## Webhook Event Responses

              When your app has received a valid and verified Weebly Event Request, it is expected that your server will respond with an HTTP 200 Status Code before the request times out.

              If you respond with anything other than an HTTP 200 to a valid Weebly Webhook Event Request, Weebly will continue to retry sending the Webhook event to your server up to 12 times over a 48 hour period.
